<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CSP | Gridea</title>
<link rel="shortcut icon" href="https://hanjianfei111.github.io/favicon.ico?v=1761811727032">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://hanjianfei111.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="CSP | Gridea - Atom Feed" href="https://hanjianfei111.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="CSP（内容安全策略）。这是一个非常重要的网络安全技术，用于防范跨站脚本（XSS）等攻击。
csp策略可通过nginx、Apache等配置文件进行配置。
一、CSP 是什么？
CSP 的核心概念是“白名单制度”。它通过一个特殊的 HTTP ..." />
    <meta name="keywords" content="" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://hanjianfei111.github.io">
  <img class="avatar" src="https://hanjianfei111.github.io/images/avatar.png?v=1761811727032" alt="">
  </a>
  <h1 class="site-title">
    Gridea
  </h1>
  <p class="site-description">
    温故而知新
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              CSP
            </h2>
            <div class="post-info">
              <span>
                2025-10-30
              </span>
              <span>
                7 min read
              </span>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <p>CSP（内容安全策略）。这是一个非常重要的网络安全技术，用于防范跨站脚本（XSS）等攻击。<br>
csp策略可通过nginx、Apache等配置文件进行配置。<br>
一、CSP 是什么？<br>
CSP 的核心概念是“白名单制度”。它通过一个特殊的 HTTP 响应头（Content-Security-Policy）告诉浏览器：“这个网页只允许加载和执行来自我明确认可的来源的资源，其他一律阻止。”<br>
换句话说，即使攻击者成功向你的网站注入了恶意脚本（例如通过XSS），如果该脚本的来源不在你批准的“白名单”上，浏览器也不会执行它，从而从根本上遏制了攻击。<br>
二、CSP 是如何工作的？一个生动的比喻<br>
想象一下你的网站是一个高级派对（你的网页），而浏览器是门口的保安（执行策略）。<br>
•	没有 CSP 的情况： 保安允许任何人（任何脚本、资源）进入派对，只要他们看起来是客人。攻击者可以轻易伪装成客人混入。<br>
•	有 CSP 的情况： 你给保安一份白名单（CSP 策略）。保安会严格检查每个想进入派对的客人（脚本、图片、样式表等），只有来自白名单上地址的客人才被允许进入。陌生人（恶意脚本）会被立刻拦在门外。<br>
三、CSP 策略详解：如何制定“白名单”？<br>
CSP 策略由一系列指令构成，每个指令控制一种特定类型资源的加载来源。<br>
常见指令及其作用<br>
指令	控制的资源	示例	解释<br>
default-src	所有资源的默认来源（是其他指令的备选方案）	default-src 'self'	默认只允许从本站加载资源。这是最重要的指令。<br>
script-src	JavaScript 脚本	script-src 'self' https://apis.google.com	只允许执行来自本站和 https://apis.google.com 的脚本。<br>
style-src	样式表	style-src 'self' 'unsafe-inline'	允许本站的样式和内联样式（不推荐）。<br>
img-src	图片	img-src 'self' data: https://cdn.example.com	允许本站图片、data:协议图片和指定CDN的图片。<br>
font-src	字体文件	font-src 'self' https://fonts.gstatic.com	允许本站和Google Fonts的字体。<br>
connect-src	网络连接	connect-src 'self' https://api.myapp.com	限制可连接的源，如 XHR、Fetch、WebSocket。<br>
frame-src	嵌入框架	frame-src https://youtube.com	限制可嵌入的框架，如 <iframe>。<br>
report-uri	违规报告	report-uri /csp-violation-report-endpoint	当策略被违反时，向此URL发送报告。<br>
常用的源关键字<br>
关键字	含义	示例<br>
'self'	只允许来自同源（相同协议、域名、端口）的资源。	script-src 'self'<br>
'none'	不允许任何来源。	object-src 'none'<br>
'unsafe-inline'	允许使用内联资源（如 <script>...</script>）。慎用！	style-src 'self' 'unsafe-inline'<br>
'unsafe-eval'	允许动态代码执行（如 eval()）。慎用！	script-src 'self' 'unsafe-eval'<br>
https:	允许所有 HTTPS 源的资源。	img-src https:<br>
data:	允许 data: URI 形式的资源（如内嵌图片）。	img-src 'self' data:<br>
四、实战示例：CSP 策略分析<br>
假设我们有一个网站，它的 CSP 头如下：<br>
Http<br>
Content-Security-Policy: default-src 'self'; script-src 'self' https://cdnjs.cloudflare.com; img-src 'self' https: data:; style-src 'self' 'unsafe-inline'; report-uri /csp-report<br>
让我们分解这个策略：</p>
<ol>
<li>default-src 'self';：<br>
o	默认规则：所有类型的资源，如果没有特别指定，都只允许从本站加载。</li>
<li>script-src 'self' https://cdnjs.cloudflare.com;：<br>
o	脚本规则：允许执行来自本站和 https://cdnjs.cloudflare.com（一个公共CDN）的JavaScript。<br>
o	效果：阻止所有其他来源的脚本，包括页面上的内联脚本（如 <script>alert('xss')</script>）和 eval() 等函数。</li>
<li>img-src 'self' https: data:;：<br>
o	图片规则：允许加载本站、任何HTTPS网站以及data:URI格式的图片。</li>
<li>style-src 'self' 'unsafe-inline';：<br>
o	样式规则：允许本站的样式表和内联样式（<style>标签）。<br>
o	注意：允许内联样式 (‘unsafe-inline’) 会降低对CSS注入攻击的防护，但有时是迁就旧代码的无奈之举。</li>
<li>report-uri /csp-report;：<br>
o	报告规则：任何违反上述策略的行为都会被浏览器记录下来，并以JSON格式发送到网站的 /csp-report 端点。这对调试和监控攻击尝试非常有用。<br>
错误示例：<br>
Content-Security-Policy: default-src https: 'unsafe-eval' 'unsafe-inline' *.test.com; img-src * data:<br>
•	https:：允许从任何 HTTPS 站点加载资源。<br>
o	影响：脚本、样式、字体、连接等都可以来自互联网上任意一个支持HTTPS的域名。这极大地扩大了攻击面。<br>
•	'unsafe-eval'：允许使用动态代码执行函数，如 eval(), setTimeout(string), new Function() 等。<br>
o	风险：许多基于DOM的XSS攻击依赖这些函数来执行恶意负载。此指令为这类攻击敞开了大门。<br>
•	'unsafe-inline'：允许执行内联资源。<br>
o	风险：允许页面中的内联 <script> 块和内联事件处理程序（如 onclick=&quot;...&quot;）。攻击者如果能够向页面注入HTML，他们注入的恶意内联脚本将能够执行。这几乎完全抵消了CSP防御XSS的核心价值。<br>
•	*.test.com：允许从 test.com 及其所有子域加载资源。<br>
o	注意：由于前面已经有了 https:，这个源指示实际上是冗余的，因为 https: 已经涵盖了所有HTTPS网站，包括 *.test.com。<br>
总结：default-src 指令实际上等同于 “允许从任何地方加载HTTPS资源，并允许执行任何形式的代码”。这为XSS攻击提供了极大的便利。<br>
五、CSP 的巨大安全价值</li>
<li>有效缓解 XSS 攻击：这是CSP最主要的目的。即使存在XSS漏洞，恶意脚本也无法执行。</li>
<li>限制资源加载：防止攻击者从恶意域名加载资源。</li>
<li>提供报告机制：通过违规报告，开发者可以及时发现和修复潜在漏洞或攻击尝试。<br>
部署建议<br>
•	从报告模式开始：在正式启用拦截策略前，可以先使用 Content-Security-Policy-Report-Only 头。该头只报告违规行为而不阻止它们，帮助你安全地测试和调整策略。<br>
•	采用“最小权限原则”：只授予必要的权限。例如，如果不需要内联脚本，就绝不使用 ‘unsafe-inline’。<br>
总结：CSP 是一种声明式的、强大的浏览器端安全机制，它通过建立可信资源白名单，极大地增加了攻击者利用XSS等漏洞的难度，是现代Web应用必备的安全防护措施之一。</li>
</ol>

              </div>
              <div class="toc-container">
                
              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://hanjianfei111.github.io/post/sudo-ti-quan/">
              <h3 class="post-title">
                SUDO提权
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="https://hanjianfei111.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
